# LatinVerbFOMA
Это курсовая, изначально написанная на 2 курсе ОТиПЛа МГУ и переработанная с использованием новой библиотеки **pyfoma**. Целью курсовой было применить к латинским глаголам процесс морфологического анализа, описанный в [этой](https://aclanthology.org/L16-1410.pdf) статье. Программа анализирует таблицы латинских глаголов из Викисловаря (выкачанные файлы [здесь](https://drive.google.com/file/d/1oMFVL_buwz9KsG0Mll7-8jRnvnAm5jQ1/view?usp=drive_link)) и строит конечный преобразователь, который распознаёт лемму и грамматические признаки латинских глагольных словоформ... или строк, похожих на них.
## Требования
Для корректной работы программы должны быть установлены библиотеки numpy, BeautifulSoup и pyfoma. В папке с проектом должна также находиться папка Verbs с html-файлами викисловарных таблиц.
## Структура и порядок использования
Ключевой модуль программы — файл **Foma.py**. При запуске он запрашивает желаемый размер обучающей выборки и строит морфологический анализатор на основе соответствующего количества латинских лексем. Непосредственно обработка файлов с таблицами происходит в модуле parse.py, к которому обращается Foma.py. Полученный анализатор сохраняется в файл **latest_FST.pkl**. Этот файл в дальнейшем можно открывать в двух других модулях, **single** и **test**.

**single.py** запрашивает у пользователя строку и возвращает результат обработки этой строки анализатором.
**test.py** запрашивает желаемый размер проверочной выборки и собирает из папки Verbs соответствующее количество таблиц, забирая из каждой по 5% от записанных там словоформ, т.е. пользователь задаёт размер выборки _в лексемах_, а размер в _словоформах_ получается в несколько раз больше, в зависимости от размера лексем. Преобразователь проверяется на словоформах из этой выборки — ему даётся форма, он возвращает набор пар "лемма + грам. признаки", его работа считается успешной, если в этом наборе есть пара из реальной леммы и реального набора признаков данной словоформы. Отдельно ведётся учёт половинчатых успехов — когда распознан набор признаков, но не распознана лемма.
### Модули "под капотом"
**parse.py** — модуль для обработки файлов таблиц.
**Morphology.py** — модуль с классами для лингвистически интуитивного представления данных при обработке таблиц: граммема, словоформа, лексема, парадигма, словоизменительная модель.
**fliss.py** — модуль для составления регулярных выражений, соответствующих словоизменительным моделям. На основе этих регулярных выражений и строится преобразователь.
**LCS.py** — модуль для нахождения наибольшей общей подпоследовательности в наборе строк. Используется для выделения в лексеме корня и аффиксов.
**wikiscan.py** — модуль, использованный для выкачки страниц с латинскими глаголами из Викисловаря. Если страницы уже есть, не нужен.
## Набор грамматических признаков
Признаки берутся из разметки Викисловаря.

**1, 2, 3** — лицо

**s, p** — число: единственное, множественное

**pres, impf, fut, perf, plup, futp** — времена: настоящее, прошедшее (имперфект), будущее, перфект, предпрошедшее (плюсквамперфект), предбудущее.

**act, pass** — залог: действительный, страдательный.

**ind, sub, imp** — наклонение: изъявительное, субъюнктив, повелительное.

**inf, part, sup, ger** — нефинитные формы: инфинитив, причастие, супин, герундий.

**nom, gen, dat, acc, abl** — падежи нефинитных форм: номинатив, генетив, датив, аккузатив, аблатив.
## Лингвистическая логика работы
Получив из таблицы набор форм некоторого слова, программа выделяет во всех этих словах наибольшую общую подпоследовательность вида *abc_de_*, где прочерками обозначены разрывы в подпоследовательности. Это "корень" слова. Всё, что не вошло в корень — это аффикс, который, соответственно, тоже может быть разрывным (хотя обычно для латыни получаются привычные неразрывные суффиксы). Тот набор грамматических признаков, который был приписан в таблице некоторой словоформе, теперь оказывается приписан аффиксу. По итогам обработки отдельной таблицы получается парадигма — корень и набор аффиксов.

Далее парадигмы сравниваются друг с другом. Если наборы аффиксов двух парагидм совпадают, либо один набор является подмножеством другого (дефектная парадигма), эти парадигмы объединяются в одну модель спряжения — набор корней + набор аффиксов.

С помощью модуля **fliss.py** в наборе корней каждой модели ищутся закономерности, которые можно описать регулярным выражением. (Если таковых нет — а обычно так и получается — регулярное выражение будет состоять только из wildcard-символа.) Эти регулярные выражения в дальнейшем используются при создании преобразователей, чтобы ограничить простор для анализа. Например, некоторый набор аффиксов может встречаться только у корней, кончающихся на одну и ту же букву. Тогда аффиксы из этого набора не будут распознаваться где попало. Если корень разрывной, для каждого кусочка делается отдельное выражение.

Наконец, с помощью библиотеки pyfoma регулярные выражения моделей преобразуются в преобразователи, которые преобразуют аффиксы модели в сочетании с её регулярным выражением в аффикс леммы (обычно 1 лицо ед.ч. praesenti indicativi activi) с перечислением грамматических признаков исходного аффикса. Например, _audīre_ может быть преобразовано в _audiō+pres|inf|act_ (вместо + в программе используется табуляция). Все эти преобразователи объекдиняются в один общий преобразователь — итог работы программы.
## Особенности и недостатки процедуры
Из-за синкретизма морфологических форм преобразователь редко подбирает единственное соответствие на данную строку. Не только на разные сочетания грам. признаков в парадигме может приходиться одна и та же форма данного глагола, но и разные глаголы могут иметь одинаковую форму в некоторой клетке парадигмы. К тому же преобразователь не знает, какие глаголы реально существовали в латыни, и может предполагать в качестве исходной формы что-то, чего не было в языке. Поэтому при оценке точности работы успехом считается, если среди десятка предложенных форм есть верная.

Традиционно в латыни выделяются четыре типа спряжения глаголов и несколько нерегулярных парадигм вроде глагола sum/esse/fui. Плюс в каждом из четырёх спряжений есть т.н. отложительные глаголы, где формы активного залога выглядят как пассивные. Из этих 4×2 спряжений программа надёжно распознаёт только классическое "первое", с инфинитивном на -āre, плюс оно же для отложительных глаголов, так как в нём наиболее регулярно образуется основа перфекта. Остальные спряжения раскалываются на десятки микроспряжений с разными чередованиями в основе, и увеличение размера обучающей выборки не сильно улучшает ситуацию.

При обучающей выборке из 50 лексем и проверочной выборке из 100 лексем точность с учётом распознавания леммы составляет 87-90%, без учёта леммы — 93-95%.
